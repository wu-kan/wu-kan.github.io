---
title: Lab6 kNN应用实践
tags:
  - 机器学习
---

## 实验目的

利用 python 实现 kNN 分类器

## 实验简介

- 导入数据，归一化数据，距离计算，实现 kNN 分类器
- 实例学习 kNN 分类器如何改进约会网站，以及识别手写数字

## 实验环境

### 硬件

所用机器型号为 VAIO Z Flip 2016

- Intel(R) Core(TM) i7-6567U CPU @3.30GHZ 3.31GHz
- 8.00GB RAM

### 软件

- Windows 10, 64-bit (Build 17763) 10.0.17763
- Visual Studio Code 1.39.2
  - Python 2019.10.41019：九月底发布的 VSCode Python 插件支持在编辑器窗口内原生运行 juyter nootbook 了，非常赞！
  - Remote - WSL 0.39.9：配合 WSL，在 Windows 上获得 Linux 接近原生环境的体验。
- Windows Subsystem for Linux [Ubuntu 18.04.2 LTS]：WSL 是以软件的形式运行在 Windows 下的 Linux 子系统，是近些年微软推出来的新工具，可以在 Windows 系统上原生运行 Linux。
  - Python 3.7.4 64-bit ('anaconda3':virtualenv)：安装在 WSL 中。

## 实现 kNN 分类器

导入两个模块：科学计算包 numpy 和运算符模块 operator。在构建完整的 kNN 分类器之前，需要编写一些基本的通用函数。

```python
# 使用createDataSet()函数创建一个简单数据集合和标签，此函数包含在knn1模块中：
>>> import knn1
# 测试函数功能：创建变量group和labels
>>> group,labels=knn1.createDataSet()
#查看变量group和labels的值
>>> group
>>> labels
# 通过函数classify()实现kNN分类器
# 测试分类器功能
>>>knn1.classify([0,0],group,labels,3)
```

输出结果是 B，可以改变输入[0,0]为其他值，测试运行结果。

## 使用 kNN 改进约会网站的配对效果

利用收集的在线约会网站的约会数据，将约会网站推荐的匹配对象归入恰当的分类（不喜欢的人，魅力一般的人，极具魅力的人）。

### 准备数据

收集的数据存放在文本文件 datingTestSet.txt 中，每条数据占一行，总共 1000 行。主要包括 3 个特征：每年获得的飞行里程数，玩游戏视频所耗时间百分比，每周消费的冰激凌公升数。在特征数据输入分类器之前，需要将待处理数据的格式转换为分类器可以接受的格式。

```python
# file2matrix函数解决格式输入问题，函数的输入为文件名字符串，输出为训练样本矩阵和类标签向量，该函数包含在knn2模块中。
>>> import knn2
>>> datingDataMat,datingLabels=knn2.file2matrix('datingTestSet2.txt')
>>> print(datingDataMat)
>>> datingLabels[0:20]
#使用Matplotlib创建散点图
>>> import matplotlib
>>> import matplotlib.pyplot as plt
>>> from numpy import*
>>> plt.scatter(datingDataMat[:,1],datingDataMat[:,2])>>> plt.show()
>>> plt.scatter(datingDataMat[:,1],datingDataMat[:,2], 15.0*array(datingLabels), 15.0*array(datingLabels))
'''
# 数据归一化处理
在处理不同取值范围的特征值时，通常采用的方法是将数值归一化，将取值范围处理为0到1或-1到1之间。如下公式可将任意取值范围的特征值转化为0到1区间内的值：
newValue=(oldValue-min)/(max-min)，其中max和min分别是数据集中的相应维度的最大特征值和最小特征值。
'''
#函数autoNorm()将数字特征值转化为0到1的区间。
>>> normMat, ranges, minVals=knn2.autoNorm(datingDataMat)
>>> normMat
>>> ranges
>>> minVals
```

### 测试分类器

利用函数 datingClassTest()测试分类器效果：

```python
>>> knn2.datingClassTest()
```

### 使用算法：构建完整可用系统

给用户提供程序，通过该程序用户会在约会网站上找到某个人并输出它的信息。程序会给出用户对对方喜欢程度的预测值。

```python
#函数classifyPerson()完成此功能
>>> knn2.classifyPerson()
```

## 使用 kNN 识别手写体

实验所用到的实际图像存储在两个子目录中：目录 trainingDigits 中包含了大约 2000 个例子，命名规则如 9_45.txt，表示该文件的分类是 9，是数字 9 的第 45 个实例，每个数字大概有 200 个实例。目录 testDigits 中包含了大约 900 个测试例子。将使用目录 trainingDigits 中的数据训练分类器，使用目录 testDigits 中的数据测试分类器的效果，两组数据没有重叠。

### 准备数据

使用 kNN 分类器，首先要将图像处理为一个向量。实验中，将把一个`32*32`的二进制图像矩阵转换成`1*1024`的向量，为此首先要编写函数 img2vector，将图像转换为向量，该函数创建`1*1024`的 Numpy 数组，然后打开给定的文件，循环读出文件的前 32 行，并将每行的前 32 个字符值存储在 Numpy 数组中，最后返回数组。

### 构建训练数据集

函数 trainingDataTest 利用目录 trainingDigits 中的文本数据构建训练集向量，以及对应的分类标签向量（标签向量可理解为对应的文件中数字的正确分类）。由于文件名的规律命名，可编写函数 classnumCut 以实现从文件名中解析分类数字，提供分类标签。注意在程序开头写上`from os import listdir`以导入 listdir 函数，它可以列出给定目录的文件名。

### 测试算法

通过测试 testDigits 目录下的样本，计算准确率。

```python
#handwrtingTest() 函数来实现分类器测试。每个数据文件中的数字按顺序展开成一个1024维的向量，而向量之间的距离用欧式距离。
#切换至文件knn3.py所在目录，并在cmd窗口执行
> python knn3.py
```

实际运行代码时，会发现 kNN 算法分类器的执行效率并不高，因为算法需要为每个测试向量计算约 2000 次欧氏距离，每个距离计算包括 1024 个维度浮点运算，全部样本要执行 900 多次，可见算法实际耗时长。另外，kNN 算法必须保存全部数据集，每次需为测试向量准备 2MB 的存储空间（2 个`1024*1024`矩阵的空间）。

## 操作练习

### 将 knn1 中的语句“from numpy import \* ”用语句“import numpy as np”代替，修改其中对应的代码，使其能够正常执行

```python
# -*- coding=utf-8 -*-

# 导入必要的库
import numpy as np
import operator

# 创建简单数据集


def createDataSet():
    group = np.array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]])
    labels = ['A', 'A', 'B', 'B']
    return group, labels

# k近邻算法


def classify(inX, dataSet, labels, k):
    # inX用于分类的输入向量
    # dataSet输入的训练样本集
    # labels为标签向量
    # k为最近的邻居数目

    # 计算距离
    dataSetSize = dataSet.shape[0]
    diffMat = np.tile(inX, (dataSetSize, 1)) - dataSet
    sqDiffMat = diffMat ** 2
    sqDistances = sqDiffMat.sum(axis=1)
    distances = sqDistances ** 0.5
    sortedDistIndicies = distances.argsort()
    classCount = {}

    # 选择距离最小的k个点
    for i in range(k):
        voteIlabel = labels[sortedDistIndicies[i]]
        classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1
    # 排序
    sortedClassCount = sorted(
        classCount.items(), key=operator.itemgetter(1), reverse=True)
    return sortedClassCount[0][0]
```

### 将 knn2 中的语句“from numpy import \* ”用语句“import numpy as np”代替，修改其中对应的代码，使其能够正常执行

```python
import numpy as np
import operator
import time

# 将文本记录转换为NumPy的解析程序


def file2matrix(filename):
    fr = open(filename)
    # 得到文件行数
    arrayOfLines = fr.readlines()
    numberOfLines = len(arrayOfLines)
    # 创建返回的Numpy矩阵
    returnMat = np.zeros((numberOfLines, 3))
    classLabelVector = []
    # 解析文件数据到列表
    index = 0
    for line in arrayOfLines:
        line = line.strip()  # 注释1
        listFromLine = line.split('\t')  # 注释2
        returnMat[index, :] = listFromLine[0:3]
        classLabelVector.append(int(listFromLine[-1]))
        index += 1
    return returnMat, classLabelVector


# 归一化特征值
def autoNorm(dataSet):
    minVals = dataSet.min(0)
    maxVals = dataSet.max(0)
    ranges = maxVals - minVals
    # 创建一个与dataSet同大小的零矩阵
    normDataSet = np.zeros(np.shape(dataSet))
    # 数据行数
    m = dataSet.shape[0]
    # tile()函数将变量内容复制成输入矩阵同等的大小
    normDataSet = dataSet - np.tile(minVals, (m, 1))
    # 特征值相除
    normDataSet = normDataSet/np.tile(ranges, (m, 1))
    return normDataSet, ranges, minVals

# k近邻算法


def classify0(inX, dataSet, labels, k):
    # inX用于分类的输入向量
    # dataSet输入的训练样本集,
    # labels为标签向量,
    # k用于选择最近的邻居数目

    # 计算距离
    dataSetSize = dataSet.shape[0]
    diffMat = np.tile(inX, (dataSetSize, 1)) - dataSet
    sqDiffMat = diffMat ** 2
    sqDistances = sqDiffMat.sum(axis=1)
    distances = sqDistances ** 0.5
    sortedDistIndicies = distances.argsort()
    classCount = {}
    # 选择距离最小的k个点
    for i in range(k):
        voteIlabel = labels[sortedDistIndicies[i]]
        classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1
    # 排序
    sortedClassCount = sorted(
        classCount.items(), key=operator.itemgetter(1), reverse=True)
    return sortedClassCount[0][0]


# 分类器针对约会网站的测试代码
def datingClassTest(k=4, h=0.10, classify=classify0):
    # 测试样本的比例
    hoRatio = h
    datingDataMat, datingLabels = file2matrix("datingTestSet2.txt")
    normMat, ranges, minVals = autoNorm(datingDataMat)
    m = normMat.shape[0]
    # 测试样本的数量
    numTestVecs = int(m*hoRatio)
    errorCount = 0.0
    for i in range(numTestVecs):
        classifierResult = classify(normMat[i, :], normMat[numTestVecs:m, :],
                                    datingLabels[numTestVecs:m], k)
        print("the classifier came back with: %d, the real answer is :%d" %
              (classifierResult, datingLabels[i]))
        if (classifierResult != datingLabels[i]):
            errorCount += 1.0
    print("the total error rate is: %f" % (errorCount/float(numTestVecs)))
    return errorCount/float(numTestVecs)


def classifyPerson(classify=classify0):
    resultList = ['not at all', 'in small doses', 'in large doses']
    percentTats = float(input("percentage of time spent playing video games?"))
    ffMiles = float(input("frequent flier miles earned per year?"))
    iceCream = float(input("liters of ice cream consumed per year?"))
    datingDataMat, datingLabels = file2matrix('datingTestSet2.txt')
    normMat, ranges, minVals = autoNorm(datingDataMat)
    inArr = np.array([ffMiles, percentTats, iceCream])
    classifierResult = classify(
        (inArr - minVals)/ranges, normMat, datingLabels, 3)
    print("You will probably like this person:",
          resultList[classifierResult - 1])
```

### 对于 knn2，测试不同 k 值对错误率的影响

```python
from matplotlib import pyplot as plt
x = []
y = []
for kk in range(1, 30):
    y.append(datingClassTest(k=kk))
    x.append(kk)

plt.plot(x, y)
plt.xlabel('k')
plt.ylabel('error rates')
```

#### 运行结果

```bash
Text(0, 0.5, 'error rates')
```

![1](data:image/png;base64,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)

### 对于 knn2，使用曼哈顿距离，观察对错误率的影响

```python
from matplotlib import pyplot as plt


def classifyManhattan(inX, dataSet, labels, k):
    # inX用于分类的输入向量
    # dataSet输入的训练样本集,
    # labels为标签向量,
    # k用于选择最近的邻居数目

    # 计算距离--曼哈顿距离

    dataSetSize = dataSet.shape[0]
    diffMat = np.tile(inX, (dataSetSize, 1)) - dataSet
    sqDiffMat = abs(diffMat)
    sqDistances = sqDiffMat.sum(axis=1)
    distances = sqDistances
    sortedDistIndicies = distances.argsort()
    classCount = {}

    # 选择距离最小的k个点
    for i in range(k):
        voteIlabel = labels[sortedDistIndicies[i]]
        classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1
    # 排序
    sortedClassCount = sorted(
        classCount.items(), key=operator.itemgetter(1), reverse=True)
    return sortedClassCount[0][0]


x = []
y = []
for kk in range(1, 30):
    y.append(datingClassTest(k=kk, classify=classifyManhattan))
    x.append(kk)

plt.plot(x, y)
plt.xlabel('k')
plt.ylabel('error rates')
```

#### 运行结果

```bash
Text(0, 0.5, 'error rates')
```

![2](data:image/png;base64,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)

### 对于 knn2，随机选取训练样本，测试不同样本数目对错误率的影响

```python
from matplotlib import pyplot as plt
r1 = []
e1 = []
for i in range(1, 10):
    r = i/10
    e1.append(datingClassTest(h=1-r))
    r1.append(r)

plt.plot(r1, e1)

plt.xlabel('rate')
plt.ylabel('error rates')
```

#### 运行结果

```bash
Text(0, 0.5, 'error rates')
```

![2](data:image/png;base64,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)

### 利用 sklearn 实现使用 kNN 改进约会网站的配对效果，并分别比较应用 PCA 前后的效果

```python
import numpy as np
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn import preprocessing
from sklearn.decomposition import PCA

X, y = file2matrix('datingTestSet2.txt')
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
knn = KNeighborsClassifier()
knn.fit(X_train, y_train)
print(knn.score(X_test, y_test, sample_weight=None))

pca1 = PCA(n_components=1)
pca1.fit(X_train)
X_train_re = pca1.transform(X_train)  # 对于训练数据和测试数据进行降维到一维数据
X_test_re = pca1.transform(X_test)
knn1 = KNeighborsClassifier()
knn1.fit(X_train_re, y_train)  # 再对降维到的一维数据进行KNN算法的训练和测试准确度
print(knn1.score(X_test_re, y_test, sample_weight=None))
print(pca1.explained_variance_ratio_)
```

#### 运行结果

```bash
0.815
0.815
[0.99999997]
```

### 利用 sklearn 实现使用 kNN 识别手写体应用，并分别比较应用 PCA 前后的效果

```python
import numpy as np
from sklearn.neighbors import KNeighborsClassifier as KNN
import time
from os import listdir


def img2vector(filename):
    '''
    filename:文件名字
    将这个文件的所有数据按照顺序写成一个一维向量并返回
    '''
    returnVect = []
    fr = open(filename)
    for i in range(32):
        lineStr = fr.readline()
        for j in range(32):
            returnVect.append(int(lineStr[j]))
    return returnVect

# 从文件名中解析分类数字


def classnumCut(fileName):
    '''
    filename:文件名
    返回这个文件数据代表的实际数字
    '''
    fileStr = fileName.split('.')[0]
    classNumStr = int(fileStr.split('_')[0])
    return classNumStr

# 构建训练集数据向量及对应分类标签向量


def trainingDataSet():
    '''
    从trainingDigits文件夹下面读取所有数据文件，返回：
    trainingMat：所有训练数据，每一行代表一个数据文件中的内容
    hwLabels：每一项表示traningMat中对应项的数据到底代表数字几
    '''
    hwLabels = []
    # 获取目录traningDigits内容(即数据集文件名)，并储存在一个list中
    trainingFileList = listdir('trainingDigits')
    m = len(trainingFileList)  # 当前目录文件数
    # 初始化m维向量的训练集，每个向量1024维
    trainingMat = np.zeros((m, 1024))
    for i in range(m):
        fileNameStr = trainingFileList[i]
        # 从文件名中解析分类数字，作为分类标签
        hwLabels.append(classnumCut(fileNameStr))
        # 将图片矩阵转换为向量并储存在新的矩阵中
        trainingMat[i, :] = img2vector('trainingDigits/%s' % fileNameStr)
    return hwLabels, trainingMat


def handwritingTest():
    # 构建训练集
    hwLabels, trainingMat = trainingDataSet()

    # 从testDigits里面拿到测试集
    testFileList = listdir('testDigits')

    # 错误数
    errorCount = 0.0

    # 测试集总样本数
    mTest = len(testFileList)

    # 获取程序运行到此处的时间（开始测试）
    t1 = time.time()

    # 构建kNN分类器
    neigh = KNN(n_neighbors=3, algorithm='auto')
    # 拟合模型, trainingMat为训练矩阵,hwLabels为对应的标签
    neigh.fit(trainingMat, hwLabels)

    for i in range(mTest):

        # 得到当前文件名
        fileNameStr = testFileList[i]

        # 从文件名中解析分类数字
        classNumStr = classnumCut(fileNameStr)

        # 将图片矩阵转换为向量
        vectorUnderTest = img2vector('testDigits/%s' % fileNameStr)

        # 调用knn算法进行测试
        classifierResult = neigh.predict([vectorUnderTest])
        print("the classifier came back with: %d, the real answer is: %d" %
              (classifierResult, classNumStr))

        # 预测结果不一致，则错误数+1
        if (classifierResult != classNumStr):
            errorCount += 1.0

    print("\nthe total number of tests is: %d" % mTest)
    print("the total number of errors is: %d" % errorCount)
    print("the total error rate is: %f" % (errorCount/float(mTest)))

    # 获取程序运行到此处的时间（结束测试）
    t2 = time.time()

    # 测试耗时
    print("Cost time: %.2fmin, %.4fs." % ((t2-t1)//60, (t2-t1) % 60))


if __name__ == "__main__":
    handwritingTest()
```

#### 运行结果

```bash
the total number of tests is: 946
the total number of errors is: 12
the total error rate is: 0.012685
Cost time: 0.00min, 6.6449s.
```

### 将 knn3 中的语句“from numpy import \* ”用语句“import numpy as np”代替，修改其中对应的代码，使其能够正常执行

```python
# -*- coding:utf-8 -*-

import numpy as np
import operator
import time
from os import listdir

# knn实现


def classify(inputPoint, dataSet, labels, k):
    '''
    inputPoint:待判断的点
    dataSet:数据集合
    labels:标签向量，维数和dataSet行数相同，比如labels[1]代表dataSet[1]的类别
    k:邻居数目
    输出：inputPoint的标签
    '''
    dataSetSize = dataSet.shape[0]

    # 先用tile函数将输入点拓展成与训练集相同维数的矩阵，再计算欧氏距离
    diffMat = np.tile(inputPoint, (dataSetSize, 1))-dataSet
    sqDiffMat = diffMat ** 2

    # 计算每一行元素之和
    sqDistances = sqDiffMat.sum(axis=1)

    # 开方得到欧拉距离矩阵
    distances = sqDistances ** 0.5

    # argsort返回的是数组从小到大的元素的索引
    # 按distances中元素进行升序排序后得到的对应下标的列表
    sortedDistIndicies = distances.argsort()

    # 选择距离最小的k个点，统计每个类别的点的个数
    classCount = {}
    for i in range(k):
        voteIlabel = labels[sortedDistIndicies[i]]
        classCount[voteIlabel] = classCount.get(voteIlabel, 0)+1

    # 按classCount字典的第2个元素（即类别出现的次数）从大到小排序
    sortedClassCount = sorted(
        classCount.items(), key=operator.itemgetter(1), reverse=True)
    return sortedClassCount[0][0]

# 将图片矩阵转换为向量


def img2vector(filename):
    '''
    filename:文件名字
    将这个文件的所有数据按照顺序写成一个一维向量并返回
    '''
    returnVect = []
    fr = open(filename)
    for i in range(32):
        lineStr = fr.readline()
        for j in range(32):
            returnVect.append(int(lineStr[j]))
    return returnVect

# 从文件名中解析分类数字


def classnumCut(fileName):
    '''
    filename:文件名
    返回这个文件数据代表的实际数字
    '''
    fileStr = fileName.split('.')[0]
    classNumStr = int(fileStr.split('_')[0])
    return classNumStr

# 构建训练集数据向量及对应分类标签向量


def trainingDataSet():
    '''
    从trainingDigits文件夹下面读取所有数据文件，返回：
    trainingMat：所有训练数据，每一行代表一个数据文件中的内容
    hwLabels：每一项表示traningMat中对应项的数据到底代表数字几
    '''
    hwLabels = []
    # 获取目录traningDigits内容(即数据集文件名)，并储存在一个list中
    trainingFileList = listdir('trainingDigits')
    m = len(trainingFileList)  # 当前目录文件数
    # 初始化m维向量的训练集，每个向量1024维
    trainingMat = np.zeros((m, 1024))
    for i in range(m):
        fileNameStr = trainingFileList[i]
        # 从文件名中解析分类数字，作为分类标签
        hwLabels.append(classnumCut(fileNameStr))
        # 将图片矩阵转换为向量并储存在新的矩阵中
        trainingMat[i, :] = img2vector('trainingDigits/%s' % fileNameStr)
    return hwLabels, trainingMat


def createDataSet():
    '''
    从trainingDigits文件夹下面读取所有数据文件，返回：
    trainingMat：所有训练数据，每一行代表一个数据文件中的内容
    hwLabels：每一项表示traningMat中对应项的数据到底代表数字几
    '''
    hwLabels = []

    # 获取目录traningDigits内容(即数据集文件名)，并储存在一个list中
    trainingFileList = listdir('trainingDigits')
    m = len(trainingFileList)  # 当前目录文件数

    # 初始化m维向量的训练集，每个向量1024维
    trainingMat = np.zeros((m, 1024))

    for i in range(m):

        fileNameStr = trainingFileList[i]

        # 从文件名中解析分类数字，作为分类标签
        hwLabels.append(classnumCut(fileNameStr))

        # 将图片矩阵转换为向量并储存在新的矩阵中
        trainingMat[i, :] = img2vector('trainingDigits/%s' % fileNameStr)
    return trainingMat, hwLabels

# 测试函数


def handwritingTest():

    # 构建训练集
    hwLabels, trainingMat = trainingDataSet()

    # 从testDigits里面拿到测试集
    testFileList = listdir('testDigits')

    # 错误数
    errorCount = 0.0

    # 测试集总样本数
    mTest = len(testFileList)

    # 获取程序运行到此处的时间（开始测试）
    t1 = time.time()

    for i in range(mTest):

        # 得到当前文件名
        fileNameStr = testFileList[i]

        # 从文件名中解析分类数字
        classNumStr = classnumCut(fileNameStr)

        # 将图片矩阵转换为向量
        vectorUnderTest = img2vector('testDigits/%s' % fileNameStr)

        # 调用knn算法进行测试
        classifierResult = classify(vectorUnderTest, trainingMat, hwLabels, 5)
        print("the classifier came back with: %d, the real answer is: %d" %
              (classifierResult, classNumStr))

        # 预测结果不一致，则错误数+1
        if (classifierResult != classNumStr):
            errorCount += 1.0

    print("\nthe total number of tests is: %d" % mTest)
    print("the total number of errors is: %d" % errorCount)
    print("the total error rate is: %f" % (errorCount/float(mTest)))

    # 获取程序运行到此处的时间（结束测试）
    t2 = time.time()

    # 测试耗时
    print("Cost time: %.2fmin, %.4fs." % ((t2-t1)//60, (t2-t1) % 60))


if __name__ == "__main__":
    handwritingTest()
```

#### 运行结果

```bash
the total number of tests is: 946
the total number of errors is: 17
the total error rate is: 0.017970
Cost time: 1.00min, 19.8545s.
```

## 实验总结

通过本次实验，我大致熟悉了 kNN 分类器的一些使用场景，原理简单但是非常实用。
